# --------------------------------------
# Author: Andreas Alfons
#         Erasmus Universiteit Rotterdam
# --------------------------------------

#' (Robust) mediation analysis
#' 
#' Perform (robust) mediation analysis via a (fast and robust) bootstrap test 
#' or Sobel's test.
#' 
#' If \code{method} is \code{"regression"} and \code{robust} is \code{TRUE} 
#' (the defaults), the tests are based on robust regressions with 
#' \code{\link[robustbase]{lmrob}}.  The bootstrap test is thereby performed 
#' via the fast and robust bootstrap.
#' 
#' If \code{method} is \code{"covariance"} and \code{robust} is \code{TRUE}, 
#' the tests are based on a Huber M-estimator of location and scatter.  For the 
#' bootstrap test, the M-estimates are used to first clean the data via a 
#' transformation.  Then the standard bootstrap is performed with the cleaned 
#' data.  Note that this covariance-based approach is less robust than the 
#' regression-based one described above.  Furthermore, the bootstrap does not 
#' account for the variability from cleaning the data.
#' 
#' @aliases print.bootTestMediation print.sobelTestMediation 
#' summary.testMediation
#' 
#' @param x  either a numeric vector containing the independent variable, or 
#' (if \code{data} is supplied) a character string, an integer or a logical 
#' vector specifying the corresponding column of \code{data}.
#' @param y  either a numeric vector containing the dependent variable, or 
#' (if \code{data} is supplied) a character string, an integer or a logical 
#' vector specifying the corresponding column of \code{data}.
#' @param m  either a numeric vector containing the proposed mediator variable, 
#' or (if \code{data} is supplied) a character string, an integer or a logical 
#' vector specifying the corresponding column of \code{data}.
#' @param covariates  optional; either a numeric vector or data frame 
#' containing additional covariates to be used as control variables, or (if 
#' \code{data} is supplied) a character, integer or logical vector specifying 
#' the corresponding column of \code{data}.
#' @param data  an optional \code{data.frame}.
#' @param test  a character string specifying the test to be performed for 
#' the indirect effect.  Possible values are \code{"boot"} (the default) for 
#' the bootstrap, or \code{"sobel"} for Sobel's test.
#' @param alternative  a character string specifying the alternative hypothesis 
#' in the test for the indirect effect.  Possible values are \code{"twosided"} 
#' (the default), \code{"less"} or \code{"greater"}.
#' @param R  an integer giving the number of bootstrap replicates.  The default 
#' is to use 5000 bootstrap replicates.
#' @param level  numeric; the confidence level of the confidence interval in 
#' the bootstrap test.  The default is to compute a 95\% confidence interval.
#' @param type  a character string specifying the type of confidence interval 
#' to be computed in the bootstrap test.  Possible values are \code{"bca"} (the 
#' default) for the bias-corrected and accelerated bootstrap, or \code{"perc"} 
#' for the percentile bootstrap.
#' @param method  a character string specifying the method of estimation for 
#' the mediation model.  Possible values are \code{"regression"} (the default) 
#' to estimate the effects via regressions, or \code{"covariance"} to estimate 
#' the effects via the covariance matrix.  Note that the effects are always 
#' estimated via regressions if control variables are specified via 
#' \code{covariates}.
#' @param robust  a logical indicating whether to perform a robust test 
#' (defaults to \code{TRUE}).
#' @param control  if \code{robust} is \code{TRUE} and \code{method} is 
#' \code{"regression"}, a list of tuning parameters for 
#' \code{\link[robustbase]{lmrob}} as generated by 
#' \code{\link{regControl}}.  If \code{robust} is \code{TRUE} 
#' and \code{method} is \code{"covariance"}, a list of tuning parameters for 
#' \code{\link{covHuber}} as generated by \code{\link{covControl}}.
#' @param \dots  additional arguments to be passed to \code{\link[boot]{boot}} 
#' in case of a bootstrap test.
#' 
#' @return An object inheriting from class \code{"testMediation"} (class 
#' \code{"bootTestMediation"} if \code{test} is \code{"boot"} or 
#' \code{"sobelTestMediation"} if \code{test} is \code{"sobel"}) with the 
#' following components:
#' @returnItem ab  numeric; the point estimate of the indirect effect.
#' @returnItem ci  a numeric vector of length two containing the bootstrap 
#' confidence interval for the indirect effect (only 
#' \code{"bootTestMediation"}).
#' @returnItem reps  an object of class \code{"\link[boot]{boot}"} containing 
#' the bootstrap replicates of the indirect effect (only 
#' \code{"bootTestMediation"}).
#' @returnItem se  numeric; the standard error of the indirect effect according 
#' to Sobel's formula (only \code{"sobelTestMediation"}).
#' @returnItem statistic  numeric; the test statistic for Sobel's test (only 
#' \code{"sobelTestMediation"}).
#' @returnItem pValue  numeric; the p-Value from Sobel's test (only 
#' \code{"sobelTestMediation"}).
#' @returnItem alternative  a character string specifying the alternative 
#' hypothesis in the test for the indirect effect.
#' @returnItem R  an integer giving the number of bootstrap replicates (only 
#' \code{"bootTestMediation"}).
#' @returnItem level  numeric; the confidence level of the bootstrap confidence 
#' interval (only \code{"bootTestMediation"}).
#' @returnItem type  a character string specifying the type of bootstrap 
#' confidence interval (only \code{"bootTestMediation"}).
#' @returnItem fit  an object inheriting from class 
#' \code{"\link{fitMediation}"} containing the estimation results for the 
#' direct effect and the total effect in the mediation model.
#' 
#' @author Andreas Alfons
#' 
#' @references
#' Preacher, K.J. and Hayes, A.F. (2004) SPSS and SAS procedures for estimating 
#' indirect effects in simple mediation models. \emph{Behavior Research Methods, 
#' Instruments, & Computers}, \bold{36}(4), 717--731.
#' 
#' Salibian-Barrera, M. and Zamar, R. (2002) Bootstrapping robust estimates of 
#' regression. \emph{The Annals of Statistics}, \bold{30}(2), 556--582.
#' 
#' Sobel, M.E. (1982) Asymptotic confidence intervals for indirect effects in 
#' structural equation models. \emph{Sociological Methodology}, \bold{13}, 
#' 290--312.
#' 
#' Zu, J. and Yuan, K.-H. (2010) Local influence and robust procedures for 
#' mediation analysis. \emph{Multivariate Behavioral Research}, \bold{45}(1), 
#' 1--44.
#' 
#' @seealso \code{\link{fitMediation}}
#' 
#' \code{\link[=coef.testMediation]{coef}}, 
#' \code{\link[=confint.testMediation]{confint}}, 
#' \code{\link[=fortify.testMediation]{fortify}} and 
#' \code{\link[=plotMediation]{plot}} methods
#' 
#' \code{\link[boot]{boot}}, \code{\link[robustbase]{lmrob}}, 
#' \code{\link[stats]{lm}}, \code{\link{covHuber}}, \code{\link{covML}}
#' 
#' @examples
#' data("superbowl")
#' testMediation("frequency", "liking", "clutter", data=superbowl)
#' 
#' @keywords multivariate
#' 
#' @import boot
#' @import robustbase
#' @export

testMediation <- function(x, y, m, covariates = NULL, data, 
                          test = c("boot", "sobel"), 
                          alternative = c("twosided", "less", "greater"), 
                          R = 5000, level = 0.95, type = c("bca", "perc"), 
                          method = c("regression", "covariance"), 
                          robust = TRUE, control, ...) {
  ## initializations
  # FIXME: make sure dimensions are correct
  if(missing(data)) {
    # prepare data frame containing all variables with original names
    x <- substitute(x)
    y <- substitute(y)
    m <- substitute(m)
    if(is.null(covariates)) {
      data <- eval.parent(call("data.frame", x, y, m))
    } else if(is.data.frame(covariates)) {
      data <- cbind(eval.parent(call("data.frame", x, y, m)), covariates)
    } else {
      covariates <- substitute(covariates)
      data <- eval.parent(call("data.frame", x, y, m, covariates))
    }
  } else {
    # prepare data set
    data <- as.data.frame(data)
    x <- data[, x, drop=FALSE]
    y <- data[, y, drop=FALSE]
    m <- data[, m, drop=FALSE]
    covariates <- data[, covariates, drop=FALSE]
    data <- cbind(x, y, m, covariates)
  }
  # extract names
  cn <- names(data)
  x <- cn[1]
  y <- cn[2]
  m <- cn[3]
  covariates <- cn[-(1:3)]
  # make sure that variables are numeric
  convert <- !sapply(data, is.numeric)
  data[convert] <- lapply(data[convert], as.numeric)
  # check if there are enough observations
  n <- nrow(data)
  if(n <= 3) stop("not enough observations")
  # check other arguments
  test <- match.arg(test)
  alternative <- match.arg(alternative)
  method <- match.arg(method)
  if(length(covariates) > 0 && method == "covariance") {
    method <- "regression"
    warning("using regression method")
  }
  robust <- isTRUE(robust)
  if(robust && missing(control)) {
    if(method == "regression") control <- regControl()
    else control <- covControl()
  }
  ## estimate effects
  if(method == "regression") {
    fit <- regFitMediation(x, y, m, covariates, data=data, 
                    robust=robust, control=control)
  } else {
    fit <- covFitMediation(x, y, m, data=data, robust=robust, control=control)
  }
  ## perform mediation analysis
  if(test == "boot") {
    level <- rep(as.numeric(level), length.out=1)
    if(is.na(level) || level < 0 || level > 1) level <- formals()$level
    type <- match.arg(type)
    ## bootstrap test
    if(method == "regression") {
      # indices of covariates in data matrix to be used in bootstrap
      j <- match(covariates, cn) + 1
      # check if fast and robust bootstrap should be applied
      if(robust) {
        # extract regression models
        fitMX <- fit$fitMX
        fitYMX <- fit$fitYMX
        # extract (square root of) robustness weights and combine data
        wM <- sqrt(weights(fitMX, type="robustness"))
        wY <- sqrt(weights(fitYMX, type="robustness"))
        z <- cbind(rep.int(1, n), as.matrix(data), wM, wY)
        # compute matrices for linear corrections
        psiControl <- getPsiControl(fitMX)  # the same for both model fits
        corrM <- correctionMatrix(z[, c(1:2, j)], weights=wM, 
                                  residuals=residuals(fitMX), 
                                  scale=fitMX$scale, 
                                  control=psiControl)
        coefM <- coef(fitMX)
        corrY <- correctionMatrix(z[, c(1, 4, 2, j)], weights=wY, 
                                  residuals=residuals(fitYMX), 
                                  scale=fitYMX$scale, 
                                  control=psiControl)
        coefY <- coef(fitYMX)
        # perform fast and robust bootstrap
        bootstrap <- localBoot(z, function(z, i, corrM, coefM, corrY, coefY) {
          # extract bootstrap sample from the data
          zi <- z[i, , drop=FALSE]
          wMi <- zi[, "wM"]
          wYi <- zi[, "wY"]
          # check whether there are enough observations with nonzero weights
          if(sum(wMi > 0) <= 2 || sum(wYi > 0) <= 3) return(NA)
          # compute coefficients from weighted regression m ~ x + covariates
          wxi <- wMi * zi[, c(1:2, j)]
          wmi <- wMi * zi[, 4]
          coefMi <- solve(crossprod(wxi)) %*% crossprod(wxi, wmi)
          # compute coefficients from weighted regression y ~ m + x + covariates
          wmxi <- wYi * zi[, c(1, 4, 2, j)]
          wyi <- wYi * zi[, 3]
          coefYi <- solve(crossprod(wmxi)) %*% crossprod(wmxi, wyi)
          # compute corrected coefficients
          coefMi <- drop(coefM + corrM %*% (coefMi - coefM))
          coefYi <- drop(coefY + corrY %*% (coefYi - coefY))
          # compute indirect effect
          unname(coefMi[2]) * unname(coefYi[2])
        }, R=R, corrM=corrM, coefM=coefM, corrY=corrY, coefY=coefY, ...)
        R <- sum(!is.na(bootstrap$t))  # adjust number of replicates for NAs
      } else {
        # combine data
        z <- cbind(rep.int(1, n), as.matrix(data))
        # perform bootstrap
        bootstrap <- localBoot(z, function(z, i) {
          # extract bootstrap sample from the data
          zi <- z[i, , drop=FALSE]
          # compute coefficients from regression m ~ x + covariates
          xi <- zi[, c(1:2, j)]
          mi <- zi[, 4]
          coefMi <- drop(solve(crossprod(xi)) %*% crossprod(xi, mi))
          # compute coefficients from regression y ~ m + x + covariates
          mxi <- zi[, c(1, 4, 2, j)]
          yi <- zi[, 3]
          coefYi <- drop(solve(crossprod(mxi)) %*% crossprod(mxi, yi))
          # compute indirect effect
          unname(coefMi[2]) * unname(coefYi[2])
        }, R=R, ...)
      }
    } else {
      # check if the robust transformation of Zu & Yuan (2010) should be applied
      if(robust) {
        cov <- fit$cov
        data[] <- mapply("-", data, cov$center, SIMPLIFY=FALSE, USE.NAMES=FALSE)
        data <- weights(cov, type="consistent") * data
      }
      # perform bootstrap
      bootstrap <- localBoot(data, function(z, i) {
        # extract bootstrap sample from the data
        zi <- z[i, , drop=FALSE]
        # compute MLE of covariance matrix on bootstrap sample
        S <- covML(zi)$cov
        # compute indirect effect
        a <- S[m, x] / S[x, x]
        b <- (-S[m,x]*S[y,x] + S[x,x]*S[y,m]) / (S[x,x]*S[m,m] - S[m,x]^2)
        a * b
      }, R=R, ...)
    }
    # extract confidence interval for indirect effect
    ci <- confint(bootstrap, level=level, alternative=alternative, type=type)
    # construct return object
    result <- list(ab=mean(bootstrap$t, na.rm=TRUE), ci=ci, reps=bootstrap, 
                   alternative=alternative, R=R, level=level, type=type, 
                   fit=fit)
    class(result) <- c("bootTestMediation", "testMediation")
  } else {
    ## Sobel test
    # extract coefficients
    a <- fit$a
    b <- fit$b
    # compute standard errors
    summary <- summary(fit)
    sa <- summary$a[1, 2]
    sb <- summary$b[1, 2]
    # compute test statistic and p-Value
    ab <- a * b
    se <- sqrt(b^2 * sa^2 + a^2 * sb^2)
    z <- ab / se
    pValue <- pValueZ(z, alternative=alternative)
    # construct return item
    result <- list(ab=ab, se=se, statistic=z, pValue=pValue, 
                   alternative=alternative, fit=fit, data=data)
    class(result) <- c("sobelTestMediation", "testMediation")
  }  
  ## return test results
  result
}


# ## wrapper function for boot() that ignores unused arguments, but allows 
# ## arguments for parallel computing to be passed down
# localBoot <- function(..., sim, stype, L, m, ran.gen, mle) boot(...)

## get control arguments for psi function as used in a given model fit
getPsiControl <- function(object) object$control[c("tuning.psi", "psi")]

## compute matrix for linear correction
correctionMatrix <- function(X, weights, residuals, scale, control) {
  tmp <- Mpsi(residuals/scale, cc=control$tuning.psi, psi=control$psi, deriv=1)
  solve(crossprod(X, tmp * X)) %*% crossprod(weights * X)
}

## internal function to compute p-value based on normal distribution
pValueZ <- function(z, alternative = c("twosided", "less", "greater")) {
  # initializations
  alternative <- match.arg(alternative)
  # compute p-value
  switch(alternative, twosided=2*pnorm(abs(z), lower.tail=FALSE), 
         less=pnorm(z), greater=pnorm(z, lower.tail=FALSE))
}
