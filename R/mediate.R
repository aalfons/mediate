# ------------------------------------
# Author: Andreas Alfons
#         Erasmus University Rotterdam
# ------------------------------------

#' (Robust) mediation analysis
#' 
#' Perform (robust) mediation analysis via a (fast and robust) bootstrap test 
#' or Sobel's test.
#' 
#' If \code{robust} is \code{TRUE} and \code{transform} is \code{FALSE} (the 
#' defaults), the tests are based on robust regressions with 
#' \code{\link[robustbase]{lmrob}}.  The bootstrap test is thereby performed 
#' via the fast and robust bootstrap.
#' 
#' If both \code{robust} and \code{transform} are \code{TRUE}, the data are 
#' first cleaned with a Huber-type transformation.  Then standard tests are 
#' performed with the cleaned data.  Note that this approach is less robust 
#' than the one described above.  Furthermore, the bootstrap does not account 
#' for the variability from cleaning the data.
#' 
#' @aliases print.bootMA print.sobelMA summary.bootMA summary.sobelMA
#' 
#' @param x  a numeric vector containing the independent variable.
#' @param y  a numeric vector containing the dependent variable.
#' @param m  a numeric vector containing the proposed mediator variable.
#' @param method  a character string specifying the test to be performed for 
#' the indirect effect.  Possible values are \code{"boot"} (the default) for 
#' the bootstrap, or \code{"sobel"} for Sobel's test.
#' @param alternative  a character string specifying the alternative hypothesis 
#' in the test for the indirect effect.  Possible values are \code{"twosided"} 
#' (the default), \code{"less"} or \code{"greater"}.
#' @param R  an integer giving the number of bootstrap replicates.  The default 
#' is to use 5000 bootstrap replicates.
#' @param level  numeric; the confidence level of the confidence interval in 
#' the bootstrap test.  The default is to compute a 95\% confidence interval.
#' @param type  a character string specifying the type of confidence interval 
#' to be computed in the bootstrap test.  Possible values are \code{"bca"} (the 
#' default) for the bias-corrected and accelerated bootstrap, or \code{"perc"} 
#' for the percentile bootstrap.
#' @param robust  a logical indicating whether to perform a robust test 
#' (defaults to \code{TRUE}).
#' @param transform  logical; if \code{robust} is \code{TRUE}, this indicates 
#' whether to clean the data with a Huber-type transformation (defaults to 
#' \code{FALSE}).
#' @param control  if \code{robust} is \code{TRUE} and \code{transform} is 
#' \code{FALSE}, a list of tuning parameters for 
#' \code{\link[robustbase]{lmrob}} as generated by 
#' \code{\link[robustbase]{lmrob.control}}.  If both \code{robust} and 
#' \code{transform} are \code{TRUE}, a list of tuning parameters for 
#' \code{\link{covHuber}} as generated by \code{\link{covHuber.control}}.
#' @param \dots  additional arguments to be passed to \code{\link[boot]{boot}} 
#' in case of a bootstrap test.
#' 
#' @return An object of class \code{"bootMA"} (if \code{method} is 
#' \code{"boot"}) or \code{"sobelMA"} (if \code{method} is \code{"sobel"}) 
#' with the following components:
#' @returnItem ab  numeric; the point estimate of the indirect effect.
#' @returnItem ci  a numeric vector of length two containing the bootstrap 
#' confidence interval for the indirect effect (only \code{"bootMA"}).
#' @returnItem reps  an object of class \code{"\link[boot]{boot}"} containing 
#' the bootstrap replicates of the indirect effect (only \code{"bootMA"}).
#' @returnItem se  numeric; the standard error of the indirect effect according 
#' to Sobel's formula (only \code{"sobelMA"}).
#' @returnItem statistic  numeric; the test statistic for Sobel's test (only 
#' \code{"sobelMA"}).
#' @returnItem pValue  numeric; the p-Value from Sobel's test (only 
#' \code{"sobelMA"}).
#' @returnItem alternative  a character string specifying the alternative 
#' hypothesis in the test for the indirect effect.
#' @returnItem R  an integer giving the number of bootstrap replicates (only 
#' \code{"bootMA"}).
#' @returnItem level  numeric; the confidence level of the bootstrap confidence 
#' interval (only \code{"bootMA"}).
#' @returnItem type  a character string specifying the type of bootstrap 
#' confidence interval (only \code{"bootMA"}).
#' @returnItem robust  a logical indicating whether a robust test was performed.
#' @returnItem transform  a logical indicating whether the data were cleaned 
#' with a Huber-type transformation.
#' @returnItem fitYX  an object of class \code{"\link[robustbase]{lmrob}"} or 
#' \code{"\link[stats]{lm}"} containing the estimation results from the 
#' regression of the dependent variable on the independent variable.
#' @returnItem fitMX  an object of class \code{"\link[robustbase]{lmrob}"} or 
#' \code{"\link[stats]{lm}"} containing the estimation results from the 
#' regression of the proposed mediator variable on the independent variable.
#' @returnItem fitYMX  an object of class \code{"\link[robustbase]{lmrob}"} or 
#' \code{"\link[stats]{lm}"} containing the estimation results from the 
#' regression of the dependent variable on the proposed mediator and 
#' independent variables.
#' @returnItem data  a data frame containing the indipendent, dependent and 
#' proposed mediator variables.
#' 
#' @author Andreas Alfons
#' 
#' @references
#' Preacher, K.J. and Hayes, A.F. (2004) SPSS and SAS procedures for estimating 
#' indirect effects in simple mediation models. \emph{Behavior Research Methods, 
#' Instruments, & Computers}, \bold{36}(4), 717--731.
#' 
#' Salibian-Barrera, M. and Zamar, R. (2002) Bootstrapping robust estimates of 
#' regression. \emph{The Annals of Statistics}, \bold{30}(2), 556--582.
#' 
#' Sobel, M.E. (1982) Asymptotic confidence intervals for indirect effects in 
#' structural equation models. \emph{Sociological Methodology}, \bold{13}, 
#' 290--312.
#' 
#' Zu, J. and Yuan, K.-H. (2010) Local influence and robust procedures for 
#' mediation analysis. \emph{Multivariate Behavioral Research}, \bold{45}(1), 
#' 1--44.
#' 
#' @seealso 
#' \code{\link[=coef.bootMA]{coef}}, \code{\link[=confint.bootMA]{confint}}, 
#' \code{\link[=fortify.bootMA]{fortify}} and \code{\link[=mediatePlot]{plot}} 
#' methods
#' 
#' \code{\link[boot]{boot}}, \code{\link[robustbase]{lmrob}}, 
#' \code{\link[stats]{lm}}, \code{\link{covHuber}}
#' 
#' 
#' @keywords multivariate
#' 
#' @import boot
#' @import robustbase
#' @export

mediate <- function(x, y, m, method = c("boot", "sobel"), 
                    alternative = c("twosided", "less", "greater"), 
                    R = 5000, level = 0.95, type = c("bca", "perc"), 
                    robust = TRUE, transform = FALSE, control, ...) {
  ## initializations
  # prepare data frame containing all variables with original names
  x <- substitute(x)
  y <- substitute(y)
  m <- substitute(m)
  data <- eval.parent(call("data.frame", x, y, m))
  # make sure that variables are numeric
  convert <- !sapply(data, is.numeric)
  data[convert] <- lapply(data[convert], as.numeric)
  # check if there are enough observations
  n <- nrow(data)
  if(n <= 3) stop("not enough observations")
  # check other arguments
  method <- match.arg(method)
  alternative <- match.arg(alternative)
  robust <- isTRUE(robust)
  transform <- robust && isTRUE(transform)
  if(robust && missing(control)) {
    control <- if(transform) covHuber.control() else lmrob.control()
  }
  ## check if the robust transformation of Zu & Yuan (2010) should be applied
  if(robust && transform) {
    huber <- covHuber(data, control=control)
    data[] <- mapply("-", data, huber$center, SIMPLIFY=FALSE, USE.NAMES=FALSE)
    data <- huber$weights * data
  }
  ## compute regression coefficients
  fYX <- as.formula(paste(y, "~", x))
  fMX <- as.formula(paste(m, "~", x))
  fYMX <- as.formula(paste(y, "~", m, "+", x))
  if(robust && !transform) {
    fitMX <- lmrob(fMX, data=data, control=control)
    fitYX <- lmrob(fYX, data=data, control=control)
    fitYMX <- lmrob(fYMX, data=data, control=control)
  } else {
    fitYX <- lm(fYX, data=data)
    fitMX <- lm(fMX, data=data)
    fitYMX <- lm(fYMX, data=data)
  }
  ## perform mediation analysis
  if(method == "boot") {
    level <- rep(as.numeric(level), length.out=1)
    if(is.na(level) || level < 0 || level > 1) level <- formals()$level
    type <- match.arg(type)
    ## bootstrap test
    if(robust && !transform) {
      # extract (square root of) robustness weights and combine data into matrix
      wM <- sqrt(weights(fitMX, type="robustness"))
      wY <- sqrt(weights(fitYMX, type="robustness"))
      z <- cbind(rep.int(1, n), as.matrix(data), wM, wY)
      # compute matrices for linear corrections
      psiControl <- getPsiControl(fitMX)  # the same for both model fits
      corrM <- correctionMatrix(z[, 1:2], weights=wM, 
                                residuals=residuals(fitMX), 
                                scale=fitMX$scale, 
                                psiControl=psiControl)
      coefM <- coef(fitMX)
      corrY <- correctionMatrix(z[, c(1, 4, 2)], weights=wY, 
                                  residuals=residuals(fitYMX), 
                                  scale=fitYMX$scale, 
                                  psiControl=psiControl)
      coefY <- coef(fitYMX)
      # perform fast and robust bootstrap
      bootstrap <- localBoot(z, function(z, i, corrM, coefM, corrY, coefY) {
        # extract bootstrap sample from the data
        zi <- z[i, , drop=FALSE]
        wMi <- zi[, "wM"]
        wYi <- zi[, "wY"]
        # check whether there are enough observations with nonzero weights
        if(sum(wMi > 0) <= 2 || sum(wYi > 0) <= 3) return(NA)
        # compute coefficients from weighted regression m ~ x
        wxi <- wMi * zi[, 1:2]
        wmi <- wMi * zi[, 4]
        coefMi <- solve(crossprod(wxi)) %*% crossprod(wxi, wmi)
        # compute coefficients from weighted regression y ~ m + x
        wmxi <- wYi * zi[, c(1, 4, 2)]
        wyi <- wYi * zi[, 3]
        coefYi <- solve(crossprod(wmxi)) %*% crossprod(wmxi, wyi)
        # compute corrected coefficients
        coefMi <- drop(coefM + corrM %*% (coefMi - coefM))
        coefYi <- drop(coefY + corrY %*% (coefYi - coefY))
        # compute indirect effect
        unname(coefMi[2]) * unname(coefYi[2])
      }, R=R, corrM=corrM, coefM=coefM, corrY=corrY, coefY=coefY, ...)
      R <- sum(!is.na(bootstrap$t))  # adjust number of replicates for NAs
    } else {
      z <- cbind(rep.int(1, n), as.matrix(data))
      bootstrap <- localBoot(z, function(z, i) {
        # extract bootstrap sample from the data
        zi <- z[i, , drop=FALSE]
        # compute coefficients from regression m ~ x
        xi <- zi[, 1:2]
        mi <- zi[, 4]
        coefMi <- drop(solve(crossprod(xi)) %*% crossprod(xi, mi))
        # compute coefficients from regression y ~ m + x
        mxi <- zi[, c(1, 4, 2)]
        yi <- zi[, 3]
        coefYi <- drop(solve(crossprod(mxi)) %*% crossprod(mxi, yi))
        # compute indirect effect
        unname(coefMi[2]) * unname(coefYi[2])
      }, R=R, ...)
    }
    # extract confidence interval for indirect effect
    ci <- confint(bootstrap, level=level, alternative=alternative, type=type)
    # construct return object
    result <- list(ab=mean(bootstrap$t, na.rm=TRUE), ci=ci, reps=bootstrap, 
                   alternative=alternative, R=R, level=level, type=type, 
                   robust=robust, transform=transform, fitYX=fitYX, 
                   fitMX=fitMX, fitYMX=fitYMX, data=data)
    class(result) <- "bootMA"
  } else {
    ## Sobel test
    a <- unname(coef(fitMX)[2])
    b <- unname(coef(fitYMX)[2])
    # compute standard errors
    summaryMX <- summary(fitMX)
    sa <- coef(summaryMX)[2, 2]
    summaryYMX <- summary(fitYMX)
    sb <- coef(summaryYMX)[2, 2]
    # compute test statistic and p-Value
    ab <- a * b
    se <- sqrt(b^2 * sa^2 + a^2 * sb^2)
    z <- ab / se
    pValue <- pvalZ(z, alternative=alternative)
    # construct return item
    result <- list(ab=ab, se=se, statistic=z, pValue=pValue, 
                   alternative=alternative, robust=robust, transform=transform, 
                   fitYX=fitYX, fitMX=fitMX, fitYMX=fitYMX, data=data)
    class(result) <- "sobelMA"
  }
  ## return test results
  result
}

## wrapper function for boot() that ignores unused arguments, but allows 
## arguments for parallel computing to be passed down
localBoot <- function(..., sim, stype, L, m, ran.gen, mle) boot(...)

## psi function (derivative of the rho function) as used by lmrob()
psi <- function(x, control, derivative = 0) {
  Mpsi(x, cc=control$tuning.psi, psi=control$psi, deriv=derivative)
}

## get control arguments for psi function as used in a given model fit
getPsiControl <- function(object) object$control[c("tuning.psi", "psi")]

## compute matrix for linear correction
correctionMatrix <- function(X, weights, residuals, scale, psiControl) {
  tmp <- psi(residuals / scale, control=psiControl, derivative=1)
  solve(crossprod(X, tmp * X)) %*% crossprod(weights * X)
}

## internal function to compute p-value based on normal distribution
pvalZ <- function(z, alternative = c("twosided", "less", "greater")) {
  # initializations
  alternative <- match.arg(alternative)
  # compute p-value
  switch(alternative, twosided=2*pnorm(-abs(z)), less=pnorm(z), 
         greater=pnorm(z, lower.tail=FALSE))
}
